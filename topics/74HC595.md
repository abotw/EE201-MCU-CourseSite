---
title: 74HC595
layout: page
parent: Topics
---

# 74HC595

|   74HC595 引脚    | 功能         | 连接到 8051       | 说明            |
| :-------------: | :--------- | :------------- | :------------ |
|   **DS (14)**   | **串行数据输入** | **P3.0**       | **发送数据位**     |
| **SH_CP (11)**  | **移位时钟输入** | **P3.1**       | **每个上升沿移入一位** |
|   **ST_CP (12)**    | **锁存时钟输入**     | **P3.2**           | **上升沿输出寄存器更新**    |
|     OE (13)     | 输出使能       | GND            | 低有效，固定为有效     |
|     MR (10)     | 主复位        | VCC            | 高有效，防止清零      |
| Q0–Q7 (15, 1–7) | 并行输出       | 接 8 个 LED（加电阻） | 输出控制信号        |
|     Q7’ (9)     | 串级输出       | 暂不使用           | 串联下一级芯片用      |
|    VCC (16)     | 电源正极       | +5V            |               |
|     GND (8)     | 电源负极       | GND            |               |

74HC595 是“**串行进 → 并行出**”：

1. **DATA（DS）**：送入一位数据（0 或 1）
    
2. **CLOCK（SH_CP）**：上升沿移入一位
    
3. 重复 8 次，移入 8 位数据
    
4. **LATCH（ST_CP）**：上升沿将 8 位数据输出到 LED

```c
#include <reg52.h>

// 引脚定义
sbit DS    = P3^0;  // 串行数据输入
sbit SH_CP = P3^1;  // 移位时钟
sbit ST_CP = P3^2;  // 锁存时钟

// 简单延时函数
void delay(unsigned int t)
{
    unsigned int i, j;
    for(i=0; i<t; i++)
        for(j=0; j<100; j++);
}

// 向 74HC595 发送一个字节（高位先发）
void HC595_SendByte(unsigned char dat)
{
    unsigned char i;
    for(i=0; i<8; i++)
    {
        DS = (dat & 0x80) ? 1 : 0;  // 输出最高位
        dat <<= 1;                  // 左移，准备下一位

        SH_CP = 0;  // 产生移位时钟上升沿
        SH_CP = 1;
    }
    // 锁存输出
    ST_CP = 0;
    ST_CP = 1;
}

void main()
{
    unsigned char i;
    while(1)
    {
        // 从 Q0 → Q7 依次点亮
        for(i=0; i<8; i++)
        {
            HC595_SendByte(1 << i);  // 仅一个 LED 亮
            delay(300);
        }

        // 从 Q7 → Q0 依次熄灭
        for(i=0; i<8; i++)
        {
            HC595_SendByte(0x80 >> i);
            delay(300);
        }
    }
}
```
